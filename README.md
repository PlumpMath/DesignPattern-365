# DesignPattern
Java设计模式简单示例，温故知新

# 创建型模式

Factory - 工厂方法模式 => 定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。
通过抽象工厂、工厂类、抽象产品、具体产品将类之间解耦。

AbstractFactory - 抽象工厂模式 => 工厂方法模式的进一步抽象，适用于不同的产品树下。

Singleton - 单例模式 => 私有化构造函数使该类仅有一个实例，并提供一个访问它的全局访问点。

Builder - 建造模式 => 建造模式可以将一个产品的内部表象与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。

Prototype - 原型模式 => 通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。

# 结构型模式

Adapter - 适配器模式 => 适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

Composite - 合成模式 => 将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式可以使客户端将单纯元素与复合元素同等看待。

Decorator - 装饰模式 => 以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。

Proxy - 代理模式 => 给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。

Flyweight - 享元模式 => 以共享的方式高效地支持大量的细粒度对象。使相同的对象不再重复创建，节省内存开销。

Facade - 外观模式 => 为了解决类与类之间的依赖关系的，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度。

Bridge - 桥梁模式 => 将抽象化与实现化脱耦，使得二者可以独立地变化。

# 行为型模式

Strategy - 策略模式 => 将每一种算法封装到具有共同接口的独立类中，根据不同的情况使用不同的算法。

Template - 模板方法模式 => 将具有相似特征的类抽象成模板，继承模板后覆盖其中的抽象方法。

Observer - 观察者模式 => 定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。在JAVA语言的java.util库里面，提供了一个Observable类以及一个Observer接口，构成JAVA语言对观察者模式的支持。

Iterator - 迭代子模式 => 顺序地访问一个聚集中的元素而不必暴露聚集的内部表象。

Chain - 责任链模式 => 很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。

Command - 命令模式 => 命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把的时候把这个对象还原到存储起来的状态。备忘录模式常常与命令模式和迭代子模式一同使用。

Memento - 备忘录模式 => 备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捕捉(Capture)住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。备忘录模式常常与命令模式和迭代子模式一同使用。

State - 状态模式 => 状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样。

Visitor - 访问者模式 => 访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。

Interpreter - 解释器模式 => 解释器模式一般用于扩展语法，使用较少

Mediator - 调停者模式 => 调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用。从而使它们可以较松散地耦合。
